<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt" />
              <option name="originalContent" value="# Set the minimum version of CMake required for this project.&#10;cmake_minimum_required(VERSION 3.22.1)&#10;&#10;# Name the project.&#10;project(&quot;kawaiiraweditor&quot;)&#10;&#10;# Use file(GLOB ...) to find all the C and C++ source files for LibRaw.&#10;# This is more robust than listing them manually.&#10;file(GLOB LIBRAW_SOURCES&#10;        &quot;libraw/internal/*.cpp&quot;&#10;        &quot;libraw/src/*.cpp&quot;&#10;        &quot;libraw/src/*.c&quot;&#10;        &quot;libraw/dcraw/*.c&quot;&#10;)&#10;&#10;# Define our library, 'kawaiiraweditor', as a shared library (.so).&#10;# It is built from our JNI wrapper and all the LibRaw source files.&#10;add_library(&#10;        kawaiiraweditor&#10;        SHARED&#10;        native-lib.cpp&#10;        ${LIBRAW_SOURCES}&#10;)&#10;&#10;# Specify the include directories needed for the compiler.&#10;target_include_directories(&#10;        kawaiiraweditor&#10;        PRIVATE&#10;        # Include directories needed by LibRaw to find its own headers.&#10;        libraw&#10;        libraw/internal&#10;        libraw/src&#10;        libraw/dcraw&#10;&#10;        # --- THE DEFINITIVE FIX IS HERE ---&#10;        # Explicitly add the NDK's system incluade path.&#10;        # This variable is provided by the Android toolchain and ensures&#10;        # that headers like &lt;android/bitmap.h&gt; are found.&#10;        ${ANDROID_NATIVE_API_LEVEL}&#10;)&#10;&#10;# Add the compile definitions required by LibRaw to build correctly.&#10;target_compile_definitions(&#10;        kawaiiraweditor&#10;        PRIVATE&#10;        NO_JASPER&#10;        NO_JPEG&#10;        NO_LCMS&#10;        LIBRAW_NODLL&#10;)&#10;&#10;# Link our library against the necessary Android NDK libraries.&#10;# These names are provided by the NDK.&#10;target_link_libraries(&#10;        kawaiiraweditor&#10;        log          # For logging to Logcat&#10;        jnigraphics  # For Android Bitmap functions&#10;)&#10;" />
              <option name="updatedContent" value="# Set the minimum version of CMake required for this project.&#10;cmake_minimum_required(VERSION 3.22.1)&#10;&#10;# Name the project.&#10;project(&quot;kawaiiraweditor&quot;)&#10;&#10;# Use file(GLOB_RECURSE ...) to find all the C and C++ source files for LibRaw, including nested subdirectories.&#10;# This is more robust than listing them manually.&#10;file(GLOB_RECURSE LIBRAW_SOURCES&#10;        &quot;libraw/internal/*.cpp&quot;&#10;        &quot;libraw/src/*.cpp&quot;&#10;        &quot;libraw/src/**/*.cpp&quot;&#10;        &quot;libraw/src/*.c&quot;&#10;        &quot;libraw/src/**/*.c&quot;&#10;        &quot;libraw/dcraw/*.c&quot;&#10;        # Include LibRaw core C++ sources where LibRaw class is implemented&#10;        &quot;libraw/libraw/*.cpp&quot;&#10;)&#10;&#10;# Exclude LibRaw alternative implementation files that cause duplicate symbols when combined&#10;list(FILTER LIBRAW_SOURCES EXCLUDE REGEX &quot;.*/postprocessing/postprocessing_ph\\.cpp$&quot;)&#10;list(FILTER LIBRAW_SOURCES EXCLUDE REGEX &quot;.*/preprocessing/preprocessing_ph\\.cpp$&quot;)&#10;list(FILTER LIBRAW_SOURCES EXCLUDE REGEX &quot;.*/write/write_ph\\.cpp$&quot;)&#10;&#10;# Define our library, 'kawaiiraweditor', as a shared library (.so).&#10;# It is built from our JNI wrapper and all the LibRaw source files.&#10;add_library(&#10;        kawaiiraweditor&#10;        SHARED&#10;        native-lib.cpp&#10;        ${LIBRAW_SOURCES}&#10;)&#10;&#10;# Specify the include directories needed for the compiler.&#10;target_include_directories(&#10;        kawaiiraweditor&#10;        PRIVATE&#10;        # Include directories needed by LibRaw to find its own headers.&#10;        libraw&#10;        libraw/internal&#10;        libraw/src&#10;        libraw/dcraw&#10;)&#10;&#10;# Add the compile definitions required by LibRaw to build correctly.&#10;target_compile_definitions(&#10;        kawaiiraweditor&#10;        PRIVATE&#10;        NO_JASPER&#10;        NO_JPEG&#10;        NO_LCMS&#10;        LIBRAW_NODLL&#10;)&#10;&#10;# Link our library against the necessary Android NDK libraries.&#10;# These names are provided by the NDK.&#10;target_link_libraries(&#10;        kawaiiraweditor&#10;        log          # For logging to Logcat&#10;        jnigraphics  # For Android Bitmap functions&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/native-lib.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/native-lib.cpp" />
              <option name="originalContent" value="#include &lt;jni.h&gt;&#10;#include &lt;android/bitmap.h&gt;&#10;#include &lt;android/log.h&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &quot;libraw/libraw.h&quot;&#10;&#10;// Helper function to log messages to Android's Logcat&#10;#define LOG_TAG &quot;KawaiiRawEditor-JNI&quot;&#10;#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)&#10;&#10;extern &quot;C&quot; JNIEXPORT jobject JNICALL&#10;Java_com_dueckis_kawaiiraweditor_LibRawDecoder_decode(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jbyteArray raw_data,&#10;        jfloat exposure) {&#10;&#10;    jbyte *raw_bytes = env-&gt;GetByteArrayElements(raw_data, nullptr);&#10;    if (!raw_bytes) {&#10;        LOGE(&quot;Failed to get byte array elements&quot;);&#10;        return nullptr;&#10;    }&#10;    jsize raw_size = env-&gt;GetArrayLength(raw_data);&#10;&#10;    LibRaw RawProcessor;&#10;    jobject bitmap = nullptr;&#10;&#10;    try {&#10;        int ret; // Variable to hold return codes&#10;&#10;        ret = RawProcessor.open_buffer(raw_bytes, raw_size);&#10;        if (ret != LIBRAW_SUCCESS) {&#10;            throw std::runtime_error(RawProcessor.strerror(ret));&#10;        }&#10;&#10;        RawProcessor.imgdata.params.bright = exposure;&#10;        RawProcessor.imgdata.params.use_camera_wb = 0;&#10;        RawProcessor.imgdata.params.use_auto_wb = 0;&#10;        RawProcessor.imgdata.params.output_bps = 8;&#10;&#10;        ret = RawProcessor.unpack();&#10;        if (ret != LIBRAW_SUCCESS) {&#10;            throw std::runtime_error(RawProcessor.strerror(ret));&#10;        }&#10;&#10;        ret = RawProcessor.dcraw_process();&#10;        if (ret != LIBRAW_SUCCESS) {&#10;            throw std::runtime_error(RawProcessor.strerror(ret));&#10;        }&#10;&#10;        libraw_processed_image_t *image = RawProcessor.dcraw_make_mem_image(&amp;ret);&#10;        if (!image) {&#10;            throw std::runtime_error(&quot;Failed to create image in memory&quot;);&#10;        }&#10;&#10;        if (image-&gt;type == LIBRAW_IMAGE_BITMAP &amp;&amp; image-&gt;colors &gt;= 3) {&#10;            AndroidBitmapInfo info;&#10;            info.width = image-&gt;width;&#10;            info.height = image-&gt;height;&#10;            info.stride = info.width * 4;&#10;            info.format = ANDROID_BITMAP_FORMAT_RGBA_8888;&#10;&#10;            if (AndroidBitmap_create(env, &amp;bitmap, &amp;info) &lt; 0) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to create Android Bitmap object&quot;);&#10;            }&#10;&#10;            void *bitmapPixels;&#10;            if (AndroidBitmap_lockPixels(env, bitmap, &amp;bitmapPixels) &lt; 0) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to lock bitmap pixels&quot;);&#10;            }&#10;&#10;            memcpy(bitmapPixels, image-&gt;data, image-&gt;data_size);&#10;            AndroidBitmap_unlockPixels(env, bitmap);&#10;&#10;        } else {&#10;            char error_msg[100];&#10;            snprintf(error_msg, sizeof(error_msg), &quot;Unsupported image type (%d) or colors (%d)&quot;, image-&gt;type, image-&gt;colors);&#10;            RawProcessor.dcraw_clear_mem(image);&#10;            throw std::runtime_error(error_msg);&#10;        }&#10;&#10;        RawProcessor.dcraw_clear_mem(image);&#10;&#10;    } catch (const std::exception&amp; e) {&#10;        LOGE(&quot;A C++ exception occurred: %s&quot;, e.what());&#10;        bitmap = nullptr;&#10;    }&#10;&#10;    RawProcessor.recycle();&#10;    env-&gt;ReleaseByteArrayElements(raw_data, raw_bytes, JNI_ABORT);&#10;&#10;    return bitmap;&#10;}" />
              <option name="updatedContent" value="#include &lt;jni.h&gt;&#10;#include &lt;android/bitmap.h&gt;&#10;#include &lt;android/log.h&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &quot;libraw/libraw.h&quot;&#10;&#10;// Helper function to log messages to Android's Logcat&#10;#define LOG_TAG &quot;KawaiiRawEditor-JNI&quot;&#10;#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)&#10;&#10;extern &quot;C&quot; JNIEXPORT jobject JNICALL&#10;Java_com_dueckis_kawaiiraweditor_LibRawDecoder_decode(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jbyteArray raw_data,&#10;        jfloat exposure) {&#10;&#10;    jbyte *raw_bytes = env-&gt;GetByteArrayElements(raw_data, nullptr);&#10;    if (!raw_bytes) {&#10;        LOGE(&quot;Failed to get byte array elements&quot;);&#10;        return nullptr;&#10;    }&#10;    jsize raw_size = env-&gt;GetArrayLength(raw_data);&#10;&#10;    LibRaw RawProcessor;&#10;    jobject bitmap = nullptr;&#10;&#10;    try {&#10;        int ret; // Variable to hold return codes&#10;&#10;        ret = RawProcessor.open_buffer(raw_bytes, raw_size);&#10;        if (ret != LIBRAW_SUCCESS) {&#10;            throw std::runtime_error(RawProcessor.strerror(ret));&#10;        }&#10;&#10;        RawProcessor.imgdata.params.bright = exposure;&#10;        RawProcessor.imgdata.params.use_camera_wb = 0;&#10;        RawProcessor.imgdata.params.use_auto_wb = 0;&#10;        RawProcessor.imgdata.params.output_bps = 8;&#10;&#10;        ret = RawProcessor.unpack();&#10;        if (ret != LIBRAW_SUCCESS) {&#10;            throw std::runtime_error(RawProcessor.strerror(ret));&#10;        }&#10;&#10;        ret = RawProcessor.dcraw_process();&#10;        if (ret != LIBRAW_SUCCESS) {&#10;            throw std::runtime_error(RawProcessor.strerror(ret));&#10;        }&#10;&#10;        libraw_processed_image_t *image = RawProcessor.dcraw_make_mem_image(&amp;ret);&#10;        if (!image) {&#10;            throw std::runtime_error(&quot;Failed to create image in memory&quot;);&#10;        }&#10;&#10;        if (image-&gt;type == LIBRAW_IMAGE_BITMAP &amp;&amp; image-&gt;colors &gt;= 3) {&#10;            // Create a Bitmap via JNI: Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)&#10;            jclass bitmapCls = env-&gt;FindClass(&quot;android/graphics/Bitmap&quot;);&#10;            if (!bitmapCls) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to find android/graphics/Bitmap class&quot;);&#10;            }&#10;            jclass configCls = env-&gt;FindClass(&quot;android/graphics/Bitmap$Config&quot;);&#10;            if (!configCls) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to find android/graphics/Bitmap$Config class&quot;);&#10;            }&#10;&#10;            jfieldID argb8888Field = env-&gt;GetStaticFieldID(configCls, &quot;ARGB_8888&quot;, &quot;Landroid/graphics/Bitmap$Config;&quot;);&#10;            if (!argb8888Field) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to get Bitmap$Config.ARGB_8888 field&quot;);&#10;            }&#10;            jobject argb8888Obj = env-&gt;GetStaticObjectField(configCls, argb8888Field);&#10;            if (!argb8888Obj) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to obtain Bitmap$Config.ARGB_8888 object&quot;);&#10;            }&#10;&#10;            jmethodID createBitmapMid = env-&gt;GetStaticMethodID(&#10;                    bitmapCls,&#10;                    &quot;createBitmap&quot;,&#10;                    &quot;(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;&quot;&#10;            );&#10;            if (!createBitmapMid) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to get Bitmap.createBitmap method&quot;);&#10;            }&#10;&#10;            bitmap = env-&gt;CallStaticObjectMethod(bitmapCls, createBitmapMid,&#10;                                                 (jint) image-&gt;width,&#10;                                                 (jint) image-&gt;height,&#10;                                                 argb8888Obj);&#10;            if (env-&gt;ExceptionCheck()) {&#10;                env-&gt;ExceptionDescribe();&#10;                env-&gt;ExceptionClear();&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Exception while calling Bitmap.createBitmap&quot;);&#10;            }&#10;            if (!bitmap) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to create Android Bitmap object&quot;);&#10;            }&#10;&#10;            void *bitmapPixels = nullptr;&#10;            if (AndroidBitmap_lockPixels(env, bitmap, &amp;bitmapPixels) &lt; 0 || !bitmapPixels) {&#10;                RawProcessor.dcraw_clear_mem(image);&#10;                throw std::runtime_error(&quot;Failed to lock bitmap pixels&quot;);&#10;            }&#10;&#10;            // Copy pixel data. LibRaw returns image-&gt;data in 8-bit samples; ensure size matches.&#10;            // We expect RGBA_8888 output; if LibRaw provides RGB, we may need to expand.&#10;            // Here we assume image-&gt;data_size matches width*height*4.&#10;            memcpy(bitmapPixels, image-&gt;data, image-&gt;data_size);&#10;            AndroidBitmap_unlockPixels(env, bitmap);&#10;&#10;        } else {&#10;            char error_msg[100];&#10;            snprintf(error_msg, sizeof(error_msg), &quot;Unsupported image type (%d) or colors (%d)&quot;, image-&gt;type, image-&gt;colors);&#10;            RawProcessor.dcraw_clear_mem(image);&#10;            throw std::runtime_error(error_msg);&#10;        }&#10;&#10;        RawProcessor.dcraw_clear_mem(image);&#10;&#10;    } catch (const std::exception&amp; e) {&#10;        LOGE(&quot;A C++ exception occurred: %s&quot;, e.what());&#10;        bitmap = nullptr;&#10;    }&#10;&#10;    RawProcessor.recycle();&#10;    env-&gt;ReleaseByteArrayElements(raw_data, raw_bytes, JNI_ABORT);&#10;&#10;    return bitmap;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>